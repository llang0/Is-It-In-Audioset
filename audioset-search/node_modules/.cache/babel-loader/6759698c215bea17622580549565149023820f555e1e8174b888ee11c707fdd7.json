{"ast":null,"code":"import { clearGlobalDnDState as $7252cd45fc48c07c$export$70936501603e6c57, DIRECTORY_DRAG_TYPE as $7252cd45fc48c07c$export$990fced5dfac2637, droppableCollectionMap as $7252cd45fc48c07c$export$dfdf5deeaf27473f, getTypes as $7252cd45fc48c07c$export$e1d41611756c6326, globalDndState as $7252cd45fc48c07c$export$6ca6700462636d0b, isInternalDropOperation as $7252cd45fc48c07c$export$78bf638634500fa5, setDropCollectionRef as $7252cd45fc48c07c$export$dac8db29d42db9a1 } from \"./utils.mjs\";\nimport { registerDropTarget as $67560de7c78cb232$export$c28d9fb4a54e471a } from \"./DragManager.mjs\";\nimport { useAutoScroll as $80d9daea3067eff3$export$6323452ca4533ed8 } from \"./useAutoScroll.mjs\";\nimport { useDrop as $5c06e4929e123553$export$ccdee5eaf73cf661 } from \"./useDrop.mjs\";\nimport { useRef as $4ZR0C$useRef, useCallback as $4ZR0C$useCallback, useEffect as $4ZR0C$useEffect } from \"react\";\nimport { useLayoutEffect as $4ZR0C$useLayoutEffect, useId as $4ZR0C$useId, mergeProps as $4ZR0C$mergeProps } from \"@react-aria/utils\";\nimport { setInteractionModality as $4ZR0C$setInteractionModality } from \"@react-aria/interactions\";\nimport { useLocale as $4ZR0C$useLocale } from \"@react-aria/i18n\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $4b52e4eff84e5217$var$DROP_POSITIONS = ['before', 'on', 'after'];\nconst $4b52e4eff84e5217$var$DROP_POSITIONS_RTL = ['after', 'on', 'before'];\nfunction $4b52e4eff84e5217$export$f4e2f423c21f7b04(props, state, ref) {\n  let localState = (0, $4ZR0C$useRef)({\n    props: props,\n    state: state,\n    nextTarget: null,\n    dropOperation: null\n  }).current;\n  localState.props = props;\n  localState.state = state;\n  let defaultOnDrop = (0, $4ZR0C$useCallback)(async e => {\n    let {\n      onInsert: onInsert,\n      onRootDrop: onRootDrop,\n      onItemDrop: onItemDrop,\n      onReorder: onReorder,\n      acceptedDragTypes = 'all',\n      shouldAcceptItemDrop: shouldAcceptItemDrop\n    } = localState.props;\n    let {\n      draggingKeys: draggingKeys\n    } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);\n    let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);\n    let {\n      target: target,\n      dropOperation: dropOperation,\n      items: items\n    } = e;\n    let filteredItems = items;\n    if (acceptedDragTypes !== 'all' || shouldAcceptItemDrop) filteredItems = items.filter(item => {\n      let itemTypes;\n      if (item.kind === 'directory') itemTypes = new Set([(0, $7252cd45fc48c07c$export$990fced5dfac2637)]);else itemTypes = item.kind === 'file' ? new Set([item.type]) : item.types;\n      if (acceptedDragTypes === 'all' || acceptedDragTypes.some(type => itemTypes.has(type))) {\n        // If we are performing a on item drop, check if the item in question accepts the dropped item since the item may have heavier restrictions\n        // than the droppable collection itself\n        if (target.type === 'item' && target.dropPosition === 'on' && shouldAcceptItemDrop) return shouldAcceptItemDrop(target, itemTypes);\n        return true;\n      }\n      return false;\n    });\n    if (filteredItems.length > 0) {\n      if (target.type === 'root' && onRootDrop) await onRootDrop({\n        items: filteredItems,\n        dropOperation: dropOperation\n      });\n      if (target.type === 'item') {\n        if (target.dropPosition === 'on' && onItemDrop) await onItemDrop({\n          items: filteredItems,\n          dropOperation: dropOperation,\n          isInternal: isInternal,\n          target: target\n        });\n        if (target.dropPosition !== 'on') {\n          if (!isInternal && onInsert) await onInsert({\n            items: filteredItems,\n            dropOperation: dropOperation,\n            target: target\n          });\n          if (isInternal && onReorder) await onReorder({\n            keys: draggingKeys,\n            dropOperation: dropOperation,\n            target: target\n          });\n        }\n      }\n    }\n  }, [localState, ref]);\n  let autoScroll = (0, $80d9daea3067eff3$export$6323452ca4533ed8)(ref);\n  let {\n    dropProps: dropProps\n  } = (0, $5c06e4929e123553$export$ccdee5eaf73cf661)({\n    ref: ref,\n    onDropEnter() {\n      state.setTarget(localState.nextTarget);\n    },\n    onDropMove(e) {\n      state.setTarget(localState.nextTarget);\n      autoScroll.move(e.x, e.y);\n    },\n    getDropOperationForPoint(types, allowedOperations, x, y) {\n      let {\n        draggingKeys: draggingKeys,\n        dropCollectionRef: dropCollectionRef\n      } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);\n      let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);\n      let isValidDropTarget = target => state.getDropOperation({\n        target: target,\n        types: types,\n        allowedOperations: allowedOperations,\n        isInternal: isInternal,\n        draggingKeys: draggingKeys\n      }) !== 'cancel';\n      let target = props.dropTargetDelegate.getDropTargetFromPoint(x, y, isValidDropTarget);\n      if (!target) {\n        localState.dropOperation = 'cancel';\n        localState.nextTarget = null;\n        return 'cancel';\n      }\n      localState.dropOperation = state.getDropOperation({\n        target: target,\n        types: types,\n        allowedOperations: allowedOperations,\n        isInternal: isInternal,\n        draggingKeys: draggingKeys\n      });\n      // If the target doesn't accept the drop, see if the root accepts it instead.\n      if (localState.dropOperation === 'cancel') {\n        let rootTarget = {\n          type: 'root'\n        };\n        let dropOperation = state.getDropOperation({\n          target: rootTarget,\n          types: types,\n          allowedOperations: allowedOperations,\n          isInternal: isInternal,\n          draggingKeys: draggingKeys\n        });\n        if (dropOperation !== 'cancel') {\n          target = rootTarget;\n          localState.dropOperation = dropOperation;\n        }\n      }\n      // Only set dropCollectionRef if there is a valid drop target since we cleanup dropCollectionRef in onDropExit\n      // which only runs when leaving a valid drop target or if the dropEffect become none (mouse dnd only).\n      if (target && localState.dropOperation !== 'cancel' && (ref === null || ref === void 0 ? void 0 : ref.current) !== (dropCollectionRef === null || dropCollectionRef === void 0 ? void 0 : dropCollectionRef.current)) (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);\n      localState.nextTarget = localState.dropOperation === 'cancel' ? null : target;\n      return localState.dropOperation;\n    },\n    onDropExit() {\n      (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(undefined);\n      state.setTarget(null);\n      autoScroll.stop();\n    },\n    onDropActivate(e) {\n      var _state_target, _state_target1;\n      if (((_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.type) === 'item' && ((_state_target1 = state.target) === null || _state_target1 === void 0 ? void 0 : _state_target1.dropPosition) === 'on' && typeof props.onDropActivate === 'function') props.onDropActivate({\n        type: 'dropactivate',\n        x: e.x,\n        y: e.y,\n        target: state.target\n      });\n    },\n    onDrop(e) {\n      (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);\n      if (state.target) onDrop(e, state.target);\n      // If there wasn't a collection being tracked as a dragged collection, then we are in a case where a non RSP drag is dropped on a\n      // RSP collection and thus we don't need to preserve the global DnD state for onDragEnd\n      let {\n        draggingCollectionRef: draggingCollectionRef\n      } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);\n      if (draggingCollectionRef == null) (0, $7252cd45fc48c07c$export$70936501603e6c57)();\n    }\n  });\n  let droppingState = (0, $4ZR0C$useRef)(null);\n  let onDrop = (0, $4ZR0C$useCallback)((e, target) => {\n    var _state_collection_getItem;\n    let {\n      state: state\n    } = localState;\n    // Focus the collection.\n    state.selectionManager.setFocused(true);\n    // Save some state of the collection/selection before the drop occurs so we can compare later.\n    let focusedKey = state.selectionManager.focusedKey;\n    // If parent key was dragged, we want to use it instead (i.e. focus row instead of cell after dropping)\n    if ((0, $7252cd45fc48c07c$export$6ca6700462636d0b).draggingKeys.has((_state_collection_getItem = state.collection.getItem(focusedKey)) === null || _state_collection_getItem === void 0 ? void 0 : _state_collection_getItem.parentKey)) {\n      focusedKey = state.collection.getItem(focusedKey).parentKey;\n      state.selectionManager.setFocusedKey(focusedKey);\n    }\n    droppingState.current = {\n      timeout: null,\n      focusedKey: focusedKey,\n      collection: state.collection,\n      selectedKeys: state.selectionManager.selectedKeys\n    };\n    let onDropFn = localState.props.onDrop || defaultOnDrop;\n    onDropFn({\n      type: 'drop',\n      x: e.x,\n      y: e.y,\n      target: target,\n      items: e.items,\n      dropOperation: e.dropOperation\n    });\n    // Wait for a short time period after the onDrop is called to allow the data to be read asynchronously\n    // and for React to re-render. If an insert occurs during this time, it will be selected/focused below.\n    // If items are not \"immediately\" inserted by the onDrop handler, the application will need to handle\n    // selecting and focusing those items themselves.\n    droppingState.current.timeout = setTimeout(() => {\n      // If focus didn't move already (e.g. due to an insert), and the user dropped on an item,\n      // focus that item and show the focus ring to give the user feedback that the drop occurred.\n      // Also show the focus ring if the focused key is not selected, e.g. in case of a reorder.\n      let {\n        state: state\n      } = localState;\n      if (target.type === 'item' && target.dropPosition === 'on' && state.collection.getItem(target.key) != null) {\n        state.selectionManager.setFocusedKey(target.key);\n        state.selectionManager.setFocused(true);\n        (0, $4ZR0C$setInteractionModality)('keyboard');\n      } else if (!state.selectionManager.isSelected(focusedKey)) (0, $4ZR0C$setInteractionModality)('keyboard');\n      droppingState.current = null;\n    }, 50);\n  }, [localState, defaultOnDrop]);\n  // eslint-disable-next-line arrow-body-style\n  (0, $4ZR0C$useEffect)(() => {\n    return () => {\n      if (droppingState.current) clearTimeout(droppingState.current.timeout);\n    };\n  }, []);\n  (0, $4ZR0C$useLayoutEffect)(() => {\n    // If an insert occurs during a drop, we want to immediately select these items to give\n    // feedback to the user that a drop occurred. Only do this if the selection didn't change\n    // since the drop started so we don't override if the user or application did something.\n    if (droppingState.current && state.selectionManager.isFocused && state.collection.size > droppingState.current.collection.size && state.selectionManager.isSelectionEqual(droppingState.current.selectedKeys)) {\n      let newKeys = new Set();\n      for (let key of state.collection.getKeys()) if (!droppingState.current.collection.getItem(key)) newKeys.add(key);\n      state.selectionManager.setSelectedKeys(newKeys);\n      // If the focused item didn't change since the drop occurred, also focus the first\n      // inserted item. If selection is disabled, then also show the focus ring so there\n      // is some indication that items were added.\n      if (state.selectionManager.focusedKey === droppingState.current.focusedKey) {\n        let first = newKeys.keys().next().value;\n        let item = state.collection.getItem(first);\n        // If this is a cell, focus the parent row.\n        if ((item === null || item === void 0 ? void 0 : item.type) === 'cell') first = item.parentKey;\n        state.selectionManager.setFocusedKey(first);\n        if (state.selectionManager.selectionMode === 'none') (0, $4ZR0C$setInteractionModality)('keyboard');\n      }\n      droppingState.current = null;\n    }\n  });\n  let {\n    direction: direction\n  } = (0, $4ZR0C$useLocale)();\n  (0, $4ZR0C$useEffect)(() => {\n    let getNextTarget = (target, wrap = true, horizontal = false) => {\n      if (!target) return {\n        type: 'root'\n      };\n      let {\n        keyboardDelegate: keyboardDelegate\n      } = localState.props;\n      let nextKey;\n      if ((target === null || target === void 0 ? void 0 : target.type) === 'item') nextKey = horizontal ? keyboardDelegate.getKeyRightOf(target.key) : keyboardDelegate.getKeyBelow(target.key);else nextKey = horizontal && direction === 'rtl' ? keyboardDelegate.getLastKey() : keyboardDelegate.getFirstKey();\n      let dropPositions = horizontal && direction === 'rtl' ? $4b52e4eff84e5217$var$DROP_POSITIONS_RTL : $4b52e4eff84e5217$var$DROP_POSITIONS;\n      let dropPosition = dropPositions[0];\n      if (target.type === 'item') {\n        // If the the keyboard delegate returned the next key in the collection,\n        // first try the other positions in the current key. Otherwise (e.g. in a grid layout),\n        // jump to the same drop position in the new key.\n        let nextCollectionKey = horizontal && direction === 'rtl' ? localState.state.collection.getKeyBefore(target.key) : localState.state.collection.getKeyAfter(target.key);\n        if (nextKey == null || nextKey === nextCollectionKey) {\n          let positionIndex = dropPositions.indexOf(target.dropPosition);\n          let nextDropPosition = dropPositions[positionIndex + 1];\n          if (positionIndex < dropPositions.length - 1 && !(nextDropPosition === dropPositions[2] && nextKey != null)) return {\n            type: 'item',\n            key: target.key,\n            dropPosition: nextDropPosition\n          };\n          // If the last drop position was 'after', then 'before' on the next key is equivalent.\n          // Switch to 'on' instead.\n          if (target.dropPosition === dropPositions[2]) dropPosition = 'on';\n        } else dropPosition = target.dropPosition;\n      }\n      if (nextKey == null) {\n        if (wrap) return {\n          type: 'root'\n        };\n        return null;\n      }\n      return {\n        type: 'item',\n        key: nextKey,\n        dropPosition: dropPosition\n      };\n    };\n    let getPreviousTarget = (target, wrap = true, horizontal = false) => {\n      let {\n        keyboardDelegate: keyboardDelegate\n      } = localState.props;\n      let nextKey;\n      if ((target === null || target === void 0 ? void 0 : target.type) === 'item') nextKey = horizontal ? keyboardDelegate.getKeyLeftOf(target.key) : keyboardDelegate.getKeyAbove(target.key);else nextKey = horizontal && direction === 'rtl' ? keyboardDelegate.getFirstKey() : keyboardDelegate.getLastKey();\n      let dropPositions = horizontal && direction === 'rtl' ? $4b52e4eff84e5217$var$DROP_POSITIONS_RTL : $4b52e4eff84e5217$var$DROP_POSITIONS;\n      let dropPosition = !target || target.type === 'root' ? dropPositions[2] : 'on';\n      if ((target === null || target === void 0 ? void 0 : target.type) === 'item') {\n        // If the the keyboard delegate returned the previous key in the collection,\n        // first try the other positions in the current key. Otherwise (e.g. in a grid layout),\n        // jump to the same drop position in the new key.\n        let prevCollectionKey = horizontal && direction === 'rtl' ? localState.state.collection.getKeyAfter(target.key) : localState.state.collection.getKeyBefore(target.key);\n        if (nextKey == null || nextKey === prevCollectionKey) {\n          let positionIndex = dropPositions.indexOf(target.dropPosition);\n          let nextDropPosition = dropPositions[positionIndex - 1];\n          if (positionIndex > 0 && nextDropPosition !== dropPositions[2]) return {\n            type: 'item',\n            key: target.key,\n            dropPosition: nextDropPosition\n          };\n          // If the last drop position was 'before', then 'after' on the previous key is equivalent.\n          // Switch to 'on' instead.\n          if (target.dropPosition === dropPositions[0]) dropPosition = 'on';\n        } else dropPosition = target.dropPosition;\n      }\n      if (nextKey == null) {\n        if (wrap) return {\n          type: 'root'\n        };\n        return null;\n      }\n      return {\n        type: 'item',\n        key: nextKey,\n        dropPosition: dropPosition\n      };\n    };\n    let nextValidTarget = (target, types, allowedDropOperations, getNextTarget, wrap = true) => {\n      let seenRoot = 0;\n      let operation;\n      let {\n        draggingKeys: draggingKeys\n      } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);\n      let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);\n      do {\n        let nextTarget = getNextTarget(target, wrap);\n        if (!nextTarget) return null;\n        target = nextTarget;\n        operation = localState.state.getDropOperation({\n          target: nextTarget,\n          types: types,\n          allowedOperations: allowedDropOperations,\n          isInternal: isInternal,\n          draggingKeys: draggingKeys\n        });\n        if (target.type === 'root') seenRoot++;\n      } while (operation === 'cancel' && !localState.state.isDropTarget(target) && seenRoot < 2);\n      if (operation === 'cancel') return null;\n      return target;\n    };\n    return $67560de7c78cb232$export$c28d9fb4a54e471a({\n      element: ref.current,\n      getDropOperation(types, allowedOperations) {\n        if (localState.state.target) {\n          let {\n            draggingKeys: draggingKeys\n          } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);\n          let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);\n          return localState.state.getDropOperation({\n            target: localState.state.target,\n            types: types,\n            allowedOperations: allowedOperations,\n            isInternal: isInternal,\n            draggingKeys: draggingKeys\n          });\n        }\n        // Check if any of the targets accept the drop.\n        // TODO: should we have a faster way of doing this or e.g. for pagination?\n        let target = nextValidTarget(null, types, allowedOperations, getNextTarget);\n        return target ? 'move' : 'cancel';\n      },\n      onDropEnter(e, drag) {\n        let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(drag.items);\n        let selectionManager = localState.state.selectionManager;\n        let target;\n        // Update the drop collection ref tracker for useDroppableItem's getDropOperation isInternal check\n        (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);\n        // When entering the droppable collection for the first time, the default drop target\n        // is after the focused key.\n        let key = selectionManager.focusedKey;\n        let dropPosition = 'after';\n        // If the focused key is a cell, get the parent item instead.\n        // For now, we assume that individual cells cannot be dropped on.\n        let item = localState.state.collection.getItem(key);\n        if ((item === null || item === void 0 ? void 0 : item.type) === 'cell') key = item.parentKey;\n        // If the focused item is also selected, the default drop target is after the last selected item.\n        // But if the focused key is the first selected item, then default to before the first selected item.\n        // This is to make reordering lists slightly easier. If you select top down, we assume you want to\n        // move the items down. If you select bottom up, we assume you want to move the items up.\n        if (selectionManager.isSelected(key)) {\n          if (selectionManager.selectedKeys.size > 1 && selectionManager.firstSelectedKey === key) dropPosition = 'before';else key = selectionManager.lastSelectedKey;\n        }\n        if (key != null) {\n          target = {\n            type: 'item',\n            key: key,\n            dropPosition: dropPosition\n          };\n          let {\n            draggingKeys: draggingKeys\n          } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);\n          let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);\n          var _nextValidTarget;\n          // If the default target is not valid, find the next one that is.\n          if (localState.state.getDropOperation({\n            target: target,\n            types: types,\n            allowedOperations: drag.allowedDropOperations,\n            isInternal: isInternal,\n            draggingKeys: draggingKeys\n          }) === 'cancel') target = (_nextValidTarget = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)) !== null && _nextValidTarget !== void 0 ? _nextValidTarget : nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);\n        }\n        // If no focused key, then start from the root.\n        if (!target) target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);\n        localState.state.setTarget(target);\n      },\n      onDropExit() {\n        (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(undefined);\n        localState.state.setTarget(null);\n      },\n      onDropTargetEnter(target) {\n        localState.state.setTarget(target);\n      },\n      onDropActivate(e) {\n        var _localState_state_target, _localState_state_target1;\n        if (((_localState_state_target = localState.state.target) === null || _localState_state_target === void 0 ? void 0 : _localState_state_target.type) === 'item' && ((_localState_state_target1 = localState.state.target) === null || _localState_state_target1 === void 0 ? void 0 : _localState_state_target1.dropPosition) === 'on' && typeof localState.props.onDropActivate === 'function') localState.props.onDropActivate({\n          type: 'dropactivate',\n          x: e.x,\n          y: e.y,\n          target: localState.state.target\n        });\n      },\n      onDrop(e, target) {\n        (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);\n        if (localState.state.target) onDrop(e, target || localState.state.target);\n      },\n      onKeyDown(e, drag) {\n        let {\n          keyboardDelegate: keyboardDelegate\n        } = localState.props;\n        let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(drag.items);\n        switch (e.key) {\n          case 'ArrowDown':\n            if (keyboardDelegate.getKeyBelow) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getNextTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          case 'ArrowUp':\n            if (keyboardDelegate.getKeyAbove) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getPreviousTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          case 'ArrowLeft':\n            if (keyboardDelegate.getKeyLeftOf) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target, wrap) => getPreviousTarget(target, wrap, true));\n              localState.state.setTarget(target);\n            }\n            break;\n          case 'ArrowRight':\n            if (keyboardDelegate.getKeyRightOf) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target, wrap) => getNextTarget(target, wrap, true));\n              localState.state.setTarget(target);\n            }\n            break;\n          case 'Home':\n            if (keyboardDelegate.getFirstKey) {\n              let target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          case 'End':\n            if (keyboardDelegate.getLastKey) {\n              let target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          case 'PageDown':\n            if (keyboardDelegate.getKeyPageBelow) {\n              let target = localState.state.target;\n              if (!target) target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);else {\n                // If on the root, go to the item a page below the top. Otherwise a page below the current item.\n                let nextKey = keyboardDelegate.getKeyPageBelow(target.type === 'item' ? target.key : keyboardDelegate.getFirstKey());\n                let dropPosition = target.type === 'item' ? target.dropPosition : 'after';\n                // If there is no next key, or we are starting on the last key, jump to the last possible position.\n                if (nextKey == null || target.type === 'item' && target.key === keyboardDelegate.getLastKey()) {\n                  nextKey = keyboardDelegate.getLastKey();\n                  dropPosition = 'after';\n                }\n                target = {\n                  type: 'item',\n                  key: nextKey,\n                  dropPosition: dropPosition\n                };\n                // If the target does not accept the drop, find the next valid target.\n                // If no next valid target, find the previous valid target.\n                let {\n                  draggingCollectionRef: draggingCollectionRef,\n                  draggingKeys: draggingKeys\n                } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);\n                let isInternal = (draggingCollectionRef === null || draggingCollectionRef === void 0 ? void 0 : draggingCollectionRef.current) === (ref === null || ref === void 0 ? void 0 : ref.current);\n                let operation = localState.state.getDropOperation({\n                  target: target,\n                  types: types,\n                  allowedOperations: drag.allowedDropOperations,\n                  isInternal: isInternal,\n                  draggingKeys: draggingKeys\n                });\n                var _nextValidTarget;\n                if (operation === 'cancel') target = (_nextValidTarget = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)) !== null && _nextValidTarget !== void 0 ? _nextValidTarget : nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);\n              }\n              localState.state.setTarget(target !== null && target !== void 0 ? target : localState.state.target);\n            }\n            break;\n          case 'PageUp':\n            {\n              if (!keyboardDelegate.getKeyPageAbove) break;\n              let target = localState.state.target;\n              if (!target) target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);else if (target.type === 'item') {\n                // If at the top already, switch to the root. Otherwise navigate a page up.\n                if (target.key === keyboardDelegate.getFirstKey()) target = {\n                  type: 'root'\n                };else {\n                  let nextKey = keyboardDelegate.getKeyPageAbove(target.key);\n                  let dropPosition = target.dropPosition;\n                  if (nextKey == null) {\n                    nextKey = keyboardDelegate.getFirstKey();\n                    dropPosition = 'before';\n                  }\n                  target = {\n                    type: 'item',\n                    key: nextKey,\n                    dropPosition: dropPosition\n                  };\n                }\n                // If the target does not accept the drop, find the previous valid target.\n                // If no next valid target, find the next valid target.\n                let {\n                  draggingKeys: draggingKeys\n                } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);\n                let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);\n                let operation = localState.state.getDropOperation({\n                  target: target,\n                  types: types,\n                  allowedOperations: drag.allowedDropOperations,\n                  isInternal: isInternal,\n                  draggingKeys: draggingKeys\n                });\n                var _nextValidTarget1;\n                if (operation === 'cancel') target = (_nextValidTarget1 = nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false)) !== null && _nextValidTarget1 !== void 0 ? _nextValidTarget1 : nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false);\n              }\n              localState.state.setTarget(target !== null && target !== void 0 ? target : localState.state.target);\n              break;\n            }\n        }\n      }\n    });\n  }, [localState, ref, onDrop, direction]);\n  let id = (0, $4ZR0C$useId)();\n  (0, $7252cd45fc48c07c$export$dfdf5deeaf27473f).set(state, {\n    id: id,\n    ref: ref\n  });\n  return {\n    collectionProps: (0, $4ZR0C$mergeProps)(dropProps, {\n      id: id,\n      // Remove description from collection element. If dropping on the entire collection,\n      // there should be a drop indicator that has this description, so no need to double announce.\n      'aria-describedby': null\n    })\n  };\n}\nexport { $4b52e4eff84e5217$export$f4e2f423c21f7b04 as useDroppableCollection };","map":{"version":3,"names":["$4b52e4eff84e5217$var$DROP_POSITIONS","$4b52e4eff84e5217$var$DROP_POSITIONS_RTL","$4b52e4eff84e5217$export$f4e2f423c21f7b04","props","state","ref","localState","$4ZR0C$useRef","nextTarget","dropOperation","current","defaultOnDrop","$4ZR0C$useCallback","e","onInsert","onRootDrop","onItemDrop","onReorder","acceptedDragTypes","shouldAcceptItemDrop","draggingKeys","$7252cd45fc48c07c$export$6ca6700462636d0b","isInternal","$7252cd45fc48c07c$export$78bf638634500fa5","target","items","filteredItems","filter","item","itemTypes","kind","Set","$7252cd45fc48c07c$export$990fced5dfac2637","type","types","some","has","dropPosition","length","keys","autoScroll","$80d9daea3067eff3$export$6323452ca4533ed8","dropProps","$5c06e4929e123553$export$ccdee5eaf73cf661","onDropEnter","setTarget","onDropMove","move","x","y","getDropOperationForPoint","allowedOperations","dropCollectionRef","isValidDropTarget","getDropOperation","dropTargetDelegate","getDropTargetFromPoint","rootTarget","$7252cd45fc48c07c$export$dac8db29d42db9a1","onDropExit","undefined","stop","onDropActivate","_state_target","_state_target1","onDrop","draggingCollectionRef","$7252cd45fc48c07c$export$70936501603e6c57","droppingState","_state_collection_getItem","selectionManager","setFocused","focusedKey","collection","getItem","parentKey","setFocusedKey","timeout","selectedKeys","onDropFn","setTimeout","key","$4ZR0C$setInteractionModality","isSelected","$4ZR0C$useEffect","clearTimeout","$4ZR0C$useLayoutEffect","isFocused","size","isSelectionEqual","newKeys","getKeys","add","setSelectedKeys","first","next","value","selectionMode","direction","$4ZR0C$useLocale","getNextTarget","wrap","horizontal","keyboardDelegate","nextKey","getKeyRightOf","getKeyBelow","getLastKey","getFirstKey","dropPositions","nextCollectionKey","getKeyBefore","getKeyAfter","positionIndex","indexOf","nextDropPosition","getPreviousTarget","getKeyLeftOf","getKeyAbove","prevCollectionKey","nextValidTarget","allowedDropOperations","seenRoot","operation","isDropTarget","$67560de7c78cb232$export$c28d9fb4a54e471a","element","drag","$7252cd45fc48c07c$export$e1d41611756c6326","firstSelectedKey","lastSelectedKey","_nextValidTarget","onDropTargetEnter","_localState_state_target","_localState_state_target1","onKeyDown","getKeyPageBelow","getKeyPageAbove","_nextValidTarget1","id","$4ZR0C$useId","$7252cd45fc48c07c$export$dfdf5deeaf27473f","set","collectionProps","$4ZR0C$mergeProps"],"sources":["/Users/gentlewomensclub/Documents/Leslie/Trained/audioset-search/node_modules/@react-aria/dnd/dist/packages/@react-aria/dnd/src/useDroppableCollection.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  clearGlobalDnDState,\n  DIRECTORY_DRAG_TYPE,\n  droppableCollectionMap,\n  getTypes,\n  globalDndState,\n  isInternalDropOperation,\n  setDropCollectionRef\n} from './utils';\nimport {\n  Collection,\n  DropEvent,\n  DropOperation,\n  DroppableCollectionDropEvent,\n  DroppableCollectionProps,\n  DropPosition,\n  DropTarget,\n  DropTargetDelegate,\n  Key,\n  KeyboardDelegate,\n  Node\n} from '@react-types/shared';\nimport * as DragManager from './DragManager';\nimport {DroppableCollectionState} from '@react-stately/dnd';\nimport {HTMLAttributes, RefObject, useCallback, useEffect, useRef} from 'react';\nimport {mergeProps, useId, useLayoutEffect} from '@react-aria/utils';\nimport {setInteractionModality} from '@react-aria/interactions';\nimport {useAutoScroll} from './useAutoScroll';\nimport {useDrop} from './useDrop';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface DroppableCollectionOptions extends DroppableCollectionProps {\n  /** A delegate object that implements behavior for keyboard focus movement. */\n  keyboardDelegate: KeyboardDelegate,\n  /** A delegate object that provides drop targets for pointer coordinates within the collection. */\n  dropTargetDelegate: DropTargetDelegate\n}\n\nexport interface DroppableCollectionResult {\n  /** Props for the collection element. */\n  collectionProps: HTMLAttributes<HTMLElement>\n}\n\ninterface DroppingState {\n  collection: Collection<Node<unknown>>,\n  focusedKey: Key,\n  selectedKeys: Set<Key>,\n  timeout: ReturnType<typeof setTimeout>\n}\n\nconst DROP_POSITIONS: DropPosition[] = ['before', 'on', 'after'];\nconst DROP_POSITIONS_RTL: DropPosition[] = ['after', 'on', 'before'];\n\n/**\n * Handles drop interactions for a collection component, with support for traditional mouse and touch\n * based drag and drop, in addition to full parity for keyboard and screen reader users.\n */\nexport function useDroppableCollection(props: DroppableCollectionOptions, state: DroppableCollectionState, ref: RefObject<HTMLElement>): DroppableCollectionResult {\n  let localState = useRef({\n    props,\n    state,\n    nextTarget: null,\n    dropOperation: null\n  }).current;\n  localState.props = props;\n  localState.state = state;\n\n  let defaultOnDrop = useCallback(async (e: DroppableCollectionDropEvent) => {\n    let {\n      onInsert,\n      onRootDrop,\n      onItemDrop,\n      onReorder,\n      acceptedDragTypes = 'all',\n      shouldAcceptItemDrop\n    } = localState.props;\n\n    let {draggingKeys} = globalDndState;\n    let isInternal = isInternalDropOperation(ref);\n    let {\n      target,\n      dropOperation,\n      items\n    } = e;\n\n    let filteredItems = items;\n    if (acceptedDragTypes !== 'all' || shouldAcceptItemDrop) {\n      filteredItems = items.filter(item => {\n        let itemTypes: Set<string | symbol>;\n        if (item.kind === 'directory') {\n          itemTypes = new Set([DIRECTORY_DRAG_TYPE]);\n        } else {\n          itemTypes = item.kind === 'file' ? new Set([item.type]) : item.types;\n        }\n\n        if (acceptedDragTypes === 'all' || acceptedDragTypes.some(type => itemTypes.has(type))) {\n          // If we are performing a on item drop, check if the item in question accepts the dropped item since the item may have heavier restrictions\n          // than the droppable collection itself\n          if (target.type === 'item' && target.dropPosition === 'on' && shouldAcceptItemDrop) {\n            return shouldAcceptItemDrop(target, itemTypes);\n          }\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    if (filteredItems.length > 0) {\n      if (target.type === 'root' && onRootDrop) {\n        await onRootDrop({items: filteredItems, dropOperation});\n      }\n\n      if (target.type === 'item') {\n        if (target.dropPosition === 'on' && onItemDrop) {\n          await onItemDrop({items: filteredItems, dropOperation, isInternal, target});\n        }\n\n        if (target.dropPosition !== 'on') {\n          if (!isInternal && onInsert) {\n            await onInsert({items: filteredItems, dropOperation, target});\n          }\n\n          if (isInternal && onReorder) {\n            await onReorder({keys: draggingKeys, dropOperation, target});\n          }\n        }\n      }\n    }\n  }, [localState, ref]);\n\n  let autoScroll = useAutoScroll(ref);\n  let {dropProps} = useDrop({\n    ref,\n    onDropEnter() {\n      state.setTarget(localState.nextTarget);\n    },\n    onDropMove(e) {\n      state.setTarget(localState.nextTarget);\n      autoScroll.move(e.x, e.y);\n    },\n    getDropOperationForPoint(types, allowedOperations, x, y) {\n      let {draggingKeys, dropCollectionRef} = globalDndState;\n      let isInternal = isInternalDropOperation(ref);\n      let isValidDropTarget = (target) => state.getDropOperation({target, types, allowedOperations, isInternal, draggingKeys}) !== 'cancel';\n      let target = props.dropTargetDelegate.getDropTargetFromPoint(x, y, isValidDropTarget);\n      if (!target) {\n        localState.dropOperation = 'cancel';\n        localState.nextTarget = null;\n        return 'cancel';\n      }\n\n      localState.dropOperation = state.getDropOperation({target, types, allowedOperations, isInternal, draggingKeys});\n\n      // If the target doesn't accept the drop, see if the root accepts it instead.\n      if (localState.dropOperation === 'cancel') {\n        let rootTarget: DropTarget = {type: 'root'};\n        let dropOperation = state.getDropOperation({target: rootTarget, types, allowedOperations, isInternal, draggingKeys});\n        if (dropOperation !== 'cancel') {\n          target = rootTarget;\n          localState.dropOperation = dropOperation;\n        }\n      }\n\n      // Only set dropCollectionRef if there is a valid drop target since we cleanup dropCollectionRef in onDropExit\n      // which only runs when leaving a valid drop target or if the dropEffect become none (mouse dnd only).\n      if (target && localState.dropOperation !== 'cancel' && ref?.current !== dropCollectionRef?.current) {\n        setDropCollectionRef(ref);\n      }\n      localState.nextTarget = localState.dropOperation === 'cancel' ? null : target;\n      return localState.dropOperation;\n    },\n    onDropExit() {\n      setDropCollectionRef(undefined);\n      state.setTarget(null);\n      autoScroll.stop();\n    },\n    onDropActivate(e) {\n      if (state.target?.type === 'item' && state.target?.dropPosition === 'on' && typeof props.onDropActivate === 'function') {\n        props.onDropActivate({\n          type: 'dropactivate',\n          x: e.x, // todo\n          y: e.y,\n          target: state.target\n        });\n      }\n    },\n    onDrop(e) {\n      setDropCollectionRef(ref);\n      if (state.target) {\n        onDrop(e, state.target);\n      }\n\n      // If there wasn't a collection being tracked as a dragged collection, then we are in a case where a non RSP drag is dropped on a\n      // RSP collection and thus we don't need to preserve the global DnD state for onDragEnd\n      let {draggingCollectionRef} = globalDndState;\n      if (draggingCollectionRef == null) {\n        clearGlobalDnDState();\n      }\n    }\n  });\n\n  let droppingState = useRef<DroppingState>(null);\n  let onDrop = useCallback((e: DropEvent, target: DropTarget) => {\n    let {state} = localState;\n\n    // Focus the collection.\n    state.selectionManager.setFocused(true);\n\n    // Save some state of the collection/selection before the drop occurs so we can compare later.\n    let focusedKey = state.selectionManager.focusedKey;\n\n    // If parent key was dragged, we want to use it instead (i.e. focus row instead of cell after dropping)\n    if (globalDndState.draggingKeys.has(state.collection.getItem(focusedKey)?.parentKey)) {\n      focusedKey = state.collection.getItem(focusedKey).parentKey;\n      state.selectionManager.setFocusedKey(focusedKey);\n    }\n\n    droppingState.current = {\n      timeout: null,\n      focusedKey,\n      collection: state.collection,\n      selectedKeys: state.selectionManager.selectedKeys\n    };\n\n    let onDropFn = localState.props.onDrop || defaultOnDrop;\n    onDropFn({\n      type: 'drop',\n      x: e.x, // todo\n      y: e.y,\n      target,\n      items: e.items,\n      dropOperation: e.dropOperation\n    });\n\n    // Wait for a short time period after the onDrop is called to allow the data to be read asynchronously\n    // and for React to re-render. If an insert occurs during this time, it will be selected/focused below.\n    // If items are not \"immediately\" inserted by the onDrop handler, the application will need to handle\n    // selecting and focusing those items themselves.\n    droppingState.current.timeout = setTimeout(() => {\n      // If focus didn't move already (e.g. due to an insert), and the user dropped on an item,\n      // focus that item and show the focus ring to give the user feedback that the drop occurred.\n      // Also show the focus ring if the focused key is not selected, e.g. in case of a reorder.\n      let {state} = localState;\n\n      if (target.type === 'item' && target.dropPosition === 'on' && state.collection.getItem(target.key) != null) {\n        state.selectionManager.setFocusedKey(target.key);\n        state.selectionManager.setFocused(true);\n        setInteractionModality('keyboard');\n      } else if (!state.selectionManager.isSelected(focusedKey)) {\n        setInteractionModality('keyboard');\n      }\n\n      droppingState.current = null;\n    }, 50);\n  }, [localState, defaultOnDrop]);\n\n  // eslint-disable-next-line arrow-body-style\n  useEffect(() => {\n    return () => {\n      if (droppingState.current) {\n        clearTimeout(droppingState.current.timeout);\n      }\n    };\n  }, []);\n\n  useLayoutEffect(() => {\n    // If an insert occurs during a drop, we want to immediately select these items to give\n    // feedback to the user that a drop occurred. Only do this if the selection didn't change\n    // since the drop started so we don't override if the user or application did something.\n    if (\n      droppingState.current &&\n      state.selectionManager.isFocused &&\n      state.collection.size > droppingState.current.collection.size &&\n      state.selectionManager.isSelectionEqual(droppingState.current.selectedKeys)\n    ) {\n      let newKeys = new Set<Key>();\n      for (let key of state.collection.getKeys()) {\n        if (!droppingState.current.collection.getItem(key)) {\n          newKeys.add(key);\n        }\n      }\n\n      state.selectionManager.setSelectedKeys(newKeys);\n\n      // If the focused item didn't change since the drop occurred, also focus the first\n      // inserted item. If selection is disabled, then also show the focus ring so there\n      // is some indication that items were added.\n      if (state.selectionManager.focusedKey === droppingState.current.focusedKey) {\n        let first = newKeys.keys().next().value;\n        let item = state.collection.getItem(first);\n\n        // If this is a cell, focus the parent row.\n        if (item?.type === 'cell') {\n          first = item.parentKey;\n        }\n\n        state.selectionManager.setFocusedKey(first);\n\n        if (state.selectionManager.selectionMode === 'none') {\n          setInteractionModality('keyboard');\n        }\n      }\n\n      droppingState.current = null;\n    }\n  });\n\n  let {direction} = useLocale();\n  useEffect(() => {\n    let getNextTarget = (target: DropTarget, wrap = true, horizontal = false): DropTarget => {\n      if (!target) {\n        return {\n          type: 'root'\n        };\n      }\n\n      let {keyboardDelegate} = localState.props;\n      let nextKey: Key;\n      if (target?.type === 'item') {\n        nextKey = horizontal ? keyboardDelegate.getKeyRightOf(target.key) : keyboardDelegate.getKeyBelow(target.key);\n      } else {\n        nextKey = horizontal && direction === 'rtl' ? keyboardDelegate.getLastKey() : keyboardDelegate.getFirstKey();\n      }\n      let dropPositions = horizontal && direction === 'rtl' ? DROP_POSITIONS_RTL : DROP_POSITIONS;\n      let dropPosition: DropPosition = dropPositions[0];\n\n      if (target.type === 'item') {\n        // If the the keyboard delegate returned the next key in the collection,\n        // first try the other positions in the current key. Otherwise (e.g. in a grid layout),\n        // jump to the same drop position in the new key.\n        let nextCollectionKey = horizontal && direction === 'rtl' ? localState.state.collection.getKeyBefore(target.key) : localState.state.collection.getKeyAfter(target.key);\n        if (nextKey == null || nextKey === nextCollectionKey) {\n          let positionIndex = dropPositions.indexOf(target.dropPosition);\n          let nextDropPosition = dropPositions[positionIndex + 1];\n          if (positionIndex < dropPositions.length - 1 && !(nextDropPosition === dropPositions[2] && nextKey != null)) {\n            return {\n              type: 'item',\n              key: target.key,\n              dropPosition: nextDropPosition\n            };\n          }\n\n          // If the last drop position was 'after', then 'before' on the next key is equivalent.\n          // Switch to 'on' instead.\n          if (target.dropPosition === dropPositions[2]) {\n            dropPosition = 'on';\n          }\n        } else {\n          dropPosition = target.dropPosition;\n        }\n      }\n\n      if (nextKey == null) {\n        if (wrap) {\n          return {\n            type: 'root'\n          };\n        }\n\n        return null;\n      }\n\n      return {\n        type: 'item',\n        key: nextKey,\n        dropPosition\n      };\n    };\n\n    let getPreviousTarget = (target: DropTarget, wrap = true, horizontal = false): DropTarget => {\n      let {keyboardDelegate} = localState.props;\n      let nextKey: Key;\n      if (target?.type === 'item') {\n        nextKey = horizontal ? keyboardDelegate.getKeyLeftOf(target.key) : keyboardDelegate.getKeyAbove(target.key);\n      } else {\n        nextKey = horizontal && direction === 'rtl' ? keyboardDelegate.getFirstKey() : keyboardDelegate.getLastKey();\n      }\n      let dropPositions = horizontal && direction === 'rtl' ? DROP_POSITIONS_RTL : DROP_POSITIONS;\n      let dropPosition: DropPosition = !target || target.type === 'root' ? dropPositions[2] : 'on';\n\n      if (target?.type === 'item') {\n        // If the the keyboard delegate returned the previous key in the collection,\n        // first try the other positions in the current key. Otherwise (e.g. in a grid layout),\n        // jump to the same drop position in the new key.\n        let prevCollectionKey = horizontal && direction === 'rtl' ? localState.state.collection.getKeyAfter(target.key) : localState.state.collection.getKeyBefore(target.key);\n        if (nextKey == null || nextKey === prevCollectionKey) {\n          let positionIndex = dropPositions.indexOf(target.dropPosition);\n          let nextDropPosition = dropPositions[positionIndex - 1];\n          if (positionIndex > 0 && nextDropPosition !== dropPositions[2]) {\n            return {\n              type: 'item',\n              key: target.key,\n              dropPosition: nextDropPosition\n            };\n          }\n\n          // If the last drop position was 'before', then 'after' on the previous key is equivalent.\n          // Switch to 'on' instead.\n          if (target.dropPosition === dropPositions[0]) {\n            dropPosition = 'on';\n          }\n        } else {\n          dropPosition = target.dropPosition;\n        }\n      }\n\n      if (nextKey == null) {\n        if (wrap) {\n          return {\n            type: 'root'\n          };\n        }\n\n        return null;\n      }\n\n      return {\n        type: 'item',\n        key: nextKey,\n        dropPosition\n      };\n    };\n\n    let nextValidTarget = (\n      target: DropTarget,\n      types: Set<string>,\n      allowedDropOperations: DropOperation[],\n      getNextTarget: (target: DropTarget, wrap: boolean) => DropTarget,\n      wrap = true\n    ): DropTarget => {\n      let seenRoot = 0;\n      let operation: DropOperation;\n      let {draggingKeys} = globalDndState;\n      let isInternal = isInternalDropOperation(ref);\n      do {\n        let nextTarget = getNextTarget(target, wrap);\n        if (!nextTarget) {\n          return null;\n        }\n        target = nextTarget;\n        operation = localState.state.getDropOperation({target: nextTarget, types, allowedOperations: allowedDropOperations, isInternal, draggingKeys});\n        if (target.type === 'root') {\n          seenRoot++;\n        }\n      } while (\n        operation === 'cancel' &&\n        !localState.state.isDropTarget(target) &&\n        seenRoot < 2\n      );\n\n      if (operation === 'cancel') {\n        return null;\n      }\n\n      return target;\n    };\n\n    return DragManager.registerDropTarget({\n      element: ref.current,\n      getDropOperation(types, allowedOperations) {\n        if (localState.state.target) {\n          let {draggingKeys} = globalDndState;\n          let isInternal = isInternalDropOperation(ref);\n          return localState.state.getDropOperation({target: localState.state.target, types, allowedOperations, isInternal, draggingKeys});\n        }\n\n        // Check if any of the targets accept the drop.\n        // TODO: should we have a faster way of doing this or e.g. for pagination?\n        let target = nextValidTarget(null, types, allowedOperations, getNextTarget);\n        return target ? 'move' : 'cancel';\n      },\n      onDropEnter(e, drag) {\n        let types = getTypes(drag.items);\n        let selectionManager = localState.state.selectionManager;\n        let target: DropTarget;\n        // Update the drop collection ref tracker for useDroppableItem's getDropOperation isInternal check\n        setDropCollectionRef(ref);\n\n        // When entering the droppable collection for the first time, the default drop target\n        // is after the focused key.\n        let key = selectionManager.focusedKey;\n        let dropPosition: DropPosition = 'after';\n\n        // If the focused key is a cell, get the parent item instead.\n        // For now, we assume that individual cells cannot be dropped on.\n        let item = localState.state.collection.getItem(key);\n        if (item?.type === 'cell') {\n          key = item.parentKey;\n        }\n\n        // If the focused item is also selected, the default drop target is after the last selected item.\n        // But if the focused key is the first selected item, then default to before the first selected item.\n        // This is to make reordering lists slightly easier. If you select top down, we assume you want to\n        // move the items down. If you select bottom up, we assume you want to move the items up.\n        if (selectionManager.isSelected(key)) {\n          if (selectionManager.selectedKeys.size > 1 && selectionManager.firstSelectedKey === key) {\n            dropPosition = 'before';\n          } else {\n            key = selectionManager.lastSelectedKey;\n          }\n        }\n\n        if (key != null) {\n          target = {\n            type: 'item',\n            key,\n            dropPosition\n          };\n\n          let {draggingKeys} = globalDndState;\n          let isInternal = isInternalDropOperation(ref);\n          // If the default target is not valid, find the next one that is.\n          if (localState.state.getDropOperation({target, types, allowedOperations: drag.allowedDropOperations, isInternal, draggingKeys}) === 'cancel') {\n            target = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)\n              ?? nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);\n          }\n        }\n\n        // If no focused key, then start from the root.\n        if (!target) {\n          target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);\n        }\n\n        localState.state.setTarget(target);\n      },\n      onDropExit() {\n        setDropCollectionRef(undefined);\n        localState.state.setTarget(null);\n      },\n      onDropTargetEnter(target) {\n        localState.state.setTarget(target);\n      },\n      onDropActivate(e) {\n        if (\n          localState.state.target?.type === 'item' &&\n          localState.state.target?.dropPosition === 'on' &&\n          typeof localState.props.onDropActivate === 'function'\n        ) {\n          localState.props.onDropActivate({\n            type: 'dropactivate',\n            x: e.x, // todo\n            y: e.y,\n            target: localState.state.target\n          });\n        }\n      },\n      onDrop(e, target) {\n        setDropCollectionRef(ref);\n        if (localState.state.target) {\n          onDrop(e, target || localState.state.target);\n        }\n      },\n      onKeyDown(e, drag) {\n        let {keyboardDelegate} = localState.props;\n        let types = getTypes(drag.items);\n        switch (e.key) {\n          case 'ArrowDown': {\n            if (keyboardDelegate.getKeyBelow) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getNextTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'ArrowUp': {\n            if (keyboardDelegate.getKeyAbove) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getPreviousTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'ArrowLeft': {\n            if (keyboardDelegate.getKeyLeftOf) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target, wrap) => getPreviousTarget(target, wrap, true));\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'ArrowRight': {\n            if (keyboardDelegate.getKeyRightOf) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target, wrap) => getNextTarget(target, wrap, true));\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'Home': {\n            if (keyboardDelegate.getFirstKey) {\n              let target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'End': {\n            if (keyboardDelegate.getLastKey) {\n              let target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'PageDown': {\n            if (keyboardDelegate.getKeyPageBelow) {\n              let target = localState.state.target;\n              if (!target) {\n                target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);\n              } else {\n                // If on the root, go to the item a page below the top. Otherwise a page below the current item.\n                let nextKey = keyboardDelegate.getKeyPageBelow(\n                  target.type === 'item'\n                    ? target.key\n                    : keyboardDelegate.getFirstKey()\n                );\n                let dropPosition = target.type === 'item' ? target.dropPosition : 'after';\n\n                // If there is no next key, or we are starting on the last key, jump to the last possible position.\n                if (nextKey == null || (target.type === 'item' && target.key === keyboardDelegate.getLastKey())) {\n                  nextKey = keyboardDelegate.getLastKey();\n                  dropPosition = 'after';\n                }\n\n                target = {\n                  type: 'item',\n                  key: nextKey,\n                  dropPosition\n                };\n\n                // If the target does not accept the drop, find the next valid target.\n                // If no next valid target, find the previous valid target.\n                let {draggingCollectionRef, draggingKeys} = globalDndState;\n                let isInternal = draggingCollectionRef?.current === ref?.current;\n                let operation = localState.state.getDropOperation({target, types, allowedOperations: drag.allowedDropOperations, isInternal, draggingKeys});\n                if (operation === 'cancel') {\n                  target = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)\n                    ?? nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);\n                }\n              }\n\n              localState.state.setTarget(target ?? localState.state.target);\n            }\n            break;\n          }\n          case 'PageUp': {\n            if (!keyboardDelegate.getKeyPageAbove) {\n              break;\n            }\n\n            let target = localState.state.target;\n            if (!target) {\n              target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);\n            } else if (target.type === 'item') {\n              // If at the top already, switch to the root. Otherwise navigate a page up.\n              if (target.key === keyboardDelegate.getFirstKey()) {\n                target = {\n                  type: 'root'\n                };\n              } else {\n                let nextKey = keyboardDelegate.getKeyPageAbove(target.key);\n                let dropPosition = target.dropPosition;\n                if (nextKey == null) {\n                  nextKey = keyboardDelegate.getFirstKey();\n                  dropPosition = 'before';\n                }\n\n                target = {\n                  type: 'item',\n                  key: nextKey,\n                  dropPosition\n                };\n              }\n\n              // If the target does not accept the drop, find the previous valid target.\n              // If no next valid target, find the next valid target.\n              let {draggingKeys} = globalDndState;\n              let isInternal = isInternalDropOperation(ref);\n              let operation = localState.state.getDropOperation({target, types, allowedOperations: drag.allowedDropOperations, isInternal, draggingKeys});\n              if (operation === 'cancel') {\n                target = nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false)\n                  ?? nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false);\n              }\n            }\n\n            localState.state.setTarget(target ?? localState.state.target);\n            break;\n          }\n        }\n      }\n    });\n  }, [localState, ref, onDrop, direction]);\n\n  let id = useId();\n  droppableCollectionMap.set(state, {id, ref});\n  return {\n    collectionProps: mergeProps(dropProps, {\n      id,\n      // Remove description from collection element. If dropping on the entire collection,\n      // there should be a drop indicator that has this description, so no need to double announce.\n      'aria-describedby': null\n    })\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}